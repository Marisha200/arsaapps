<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mensajería CHAMP - ARSA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Encabezado azul con botón de volver -->
    <header class="bg-gradient-to-r from-blue-600 to-blue-800 shadow-lg relative">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8 text-center">
            <a href="index.html" class="absolute top-1/2 left-4 sm:left-6 lg:left-8 -translate-y-1/2 text-white hover:bg-white/20 p-2 rounded-full transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                </svg>
            </a>
            <h1 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white">Mensajería CHAMP</h1>
        </div>
    </header>

    <!-- Contenido Principal -->
    <main class="py-12">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="max-w-7xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8">
                <h2 class="text-xl sm:text-2xl font-bold text-gray-800 mb-2 text-center">Extractor de Datos XML</h2>
                <p class="text-center text-gray-600 mb-6">Selecciona el tipo de mensaje y pega el contenido para generar una planilla.</p>
                
                <div class="mb-4 max-w-xs mx-auto">
                    <label for="messageType" class="block text-sm font-medium text-gray-700 mb-2">Tipo de Mensaje:</label>
                    <select id="messageType" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="FWB" selected>FWB</option>
                        <option value="FFM">FFM</option>
                    </select>
                </div>

                <textarea id="xmlInput" rows="15" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow mb-4" placeholder="Pega aquí el contenido de tus archivos XML..."></textarea>

                <div class="flex flex-wrap items-center justify-center gap-3 mb-4">
                    <button id="processBtn" class="bg-blue-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                        Procesar XML
                    </button>
                    <button id="clearBtn" class="bg-gray-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-gray-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                        Limpiar Todo
                    </button>
                    <button id="filterBtn" class="bg-yellow-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-yellow-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500">
                        Mostrar solo incorrectos
                    </button>
                    <button id="copyBtn" class="bg-green-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                        Copiar Tabla
                    </button>
                    <button id="exportBtn" class="bg-teal-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-teal-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500">
                        Exportar a XLS
                    </button>
                </div>
                <div id="statusMessage" class="text-center text-sm text-gray-600 min-h-[20px]"></div>

                <div class="mt-8 overflow-x-auto">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Resultados</h3>
                    <div class="border border-gray-200 rounded-lg overflow-hidden">
                        <table id="resultsTable" class="min-w-full divide-y divide-gray-200">
                            <thead id="tableHeader" class="bg-gray-100">
                                <!-- Headers will be generated dynamically -->
                            </thead>
                            <tbody id="resultsTableBody" class="bg-white divide-y divide-gray-200">
                                <!-- Los resultados se insertarán aquí -->
                            </tbody>
                        </table>
                    </div>
                    <p id="noResults" class="text-center text-gray-500 py-8">Aún no hay datos para mostrar.</p>
                </div>
            </div>
        </div>
    </main>

    <footer class="text-center py-4 text-sm text-gray-500">
        <p>Marina - ARSA</p>
    </footer>
    
    <script>
        // --- Element Constants ---
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const copyBtn = document.getElementById('copyBtn');
        const exportBtn = document.getElementById('exportBtn');
        const filterBtn = document.getElementById('filterBtn');
        const xmlInput = document.getElementById('xmlInput');
        const tableHeader = document.getElementById('tableHeader');
        const tableBody = document.getElementById('resultsTableBody');
        const statusMessage = document.getElementById('statusMessage');
        const noResults = document.getElementById('noResults');
        const messageType = document.getElementById('messageType');
        let isFilterActive = false;

        // --- Function Declarations ---
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = 'text-center text-sm min-h-[20px]'; // Reset classes
            if (type === 'success') {
                statusMessage.classList.add('text-green-600');
            } else if (type === 'error') {
                statusMessage.classList.add('text-red-600');
            } else {
                statusMessage.classList.add('text-gray-600');
            }
        }

        function updateTableVisibility() {
            const tableContainer = document.getElementById('resultsTable').closest('.border');
            if (tableBody.rows.length > 0) {
                noResults.style.display = 'none';
                tableContainer.style.display = 'block';
            } else {
                noResults.style.display = 'block';
                tableContainer.style.display = 'none';
            }
        }

        function updateTableHeaders(type) {
            tableHeader.innerHTML = '';
            let headers = [];
            if (type === 'FWB') {
                headers = ['Fecha', 'From', 'To', 'AWB', 'Origen', 'Destino', 'Status'];
            } else if (type === 'FFM') {
                headers = ['Fecha', 'Nro Vuelo', 'Origen', 'Destino', 'Status'];
            }
            const headerRow = document.createElement('tr');
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-6 py-3 text-left text-xs font-bold text-gray-600 uppercase tracking-wider';
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);
        }

        function processXMLs() {
            const selectedType = messageType.value;
            const rawText = xmlInput.value;
            if (!rawText.trim()) {
                showStatus('El campo de XML está vacío.', 'error');
                return;
            }
            tableBody.innerHTML = '';

            const isFWB = selectedType === 'FWB';
            const forbiddenDestinations = isFWB 
                ? ['EZE', 'AEP', 'MDZ', 'MDQ', 'SLA', 'COR', 'IGR', 'RGA', 'USH']
                : ['AEP', 'EZE', 'BRC', 'CRD', 'COR', 'CNQ', 'FTE', 'EPA', 'EQS', 'FMA', 'MDQ', 'MDZ', 'NQN', 'PSS', 'IGR', 'RES', 'RGL', 'RGA', 'ROS', 'SLA', 'JUJ', 'RHD', 'SDE', 'UAQ', 'MJR', 'AFA', 'RSA', 'SFN', 'VDM', 'USH', 'PMY', 'REL', 'NEC', 'PEH', 'LGS', 'ORA', 'IRJ', 'TTG', 'CTJ', 'ING', 'CLX', 'GGS'];

            // Split by the XML declaration to handle multiple files pasted together
            const chunks = rawText.split(/(?=<\?xml)/g);
            let xmlStrings = chunks.filter(chunk => chunk.trim().length > 0);

            if (xmlStrings.length === 0 && rawText.trim().startsWith('<')) {
                xmlStrings.push(rawText.trim());
            }

            let processedCount = 0, errorCount = 0, correctCount = 0, incorrectCount = 0;

            if (xmlStrings.length === 0) {
                showStatus('No se encontró contenido con formato XML para procesar.', 'error');
                updateTableVisibility();
                return;
            }

            const parser = new DOMParser();
            xmlStrings.forEach(xmlString => {
                if (!xmlString) return;
                
                try {
                    // Clean the string before parsing
                    let cleanXmlString = xmlString.trim();
                    if (cleanXmlString.startsWith('"') && cleanXmlString.endsWith('"')) {
                        cleanXmlString = cleanXmlString.substring(1, cleanXmlString.length - 1);
                    }
                    cleanXmlString = cleanXmlString.replace(/""/g, '"');

                    const xmlDoc = parser.parseFromString(cleanXmlString, "application/xml");
                    if (xmlDoc.querySelector("parsererror")) {
                         throw new Error("XML mal formado.");
                    }

                    const getTagValue = (tagName, parentNode = xmlDoc) => {
                        const tags = parentNode.querySelectorAll(`${tagName}`); // Removed direct child selector for flexibility
                        return tags.length > 0 ? tags[tags.length - 1].textContent.trim() : 'N/A';
                    };
                    
                    if (isFWB) {
                        processFWB(xmlDoc, getTagValue, forbiddenDestinations);
                    } else {
                        processFFM(xmlDoc, getTagValue, forbiddenDestinations);
                    }

                } catch (e) {
                    console.error("Error procesando un XML:", e.message, xmlString);
                    errorCount++;
                }
            });

            function processFWB(xmlDoc, getTagValue, forbiddenDests) {
                const day = getTagValue('DateOfMonth');
                const month = getTagValue('Month');
                const year = getTagValue('Year');
                const date = (day !== 'N/A' && month !== 'N/A' && year !== 'N/A') ? `${day}/${month}/${year}` : 'N/A';
                const from = getTagValue('From');
                const to = getTagValue('To');
                const airlinePrefix = getTagValue('AirlinePrefix');
                const awbSerial = getTagValue('AwbSerialNumber');
                const awb = (airlinePrefix !== 'N/A' && awbSerial !== 'N/A') ? `${airlinePrefix}-${awbSerial}` : 'N/A';
                const orgAirpCode = getTagValue('orgAirpCode');
                const dstAirpCode = getTagValue('dstAirpCode');
                
                if ([date, from, to, awb, orgAirpCode, dstAirpCode].some(val => val === 'N/A')) return;

                const isIncorrect = forbiddenDests.includes(dstAirpCode.toUpperCase());
                const row = tableBody.insertRow();
                populateRow(row, isIncorrect, [date, from, to, awb, orgAirpCode, dstAirpCode]);
            }

            function processFFM(xmlDoc, getTagValue, forbiddenDests) {
                const flightLegs = xmlDoc.querySelectorAll('FlightLeg');
                flightLegs.forEach(leg => {
                    const date = getTagValue('Date', xmlDoc);
                    const carrier = getTagValue('Carrier', leg);
                    const number = getTagValue('Number', leg);
                    const day = getTagValue('Day', leg);
                    const month = getTagValue('Month', leg);
                    const flightNum = (carrier !== 'N/A' && number !== 'N/A' && day !== 'N/A' && month !== 'N/A')
                        ? `${carrier}${number}/${day}${month}` : 'N/A';
                    
                    const origin = getTagValue('AirportOfLoading', leg);
                    const destination = getTagValue('AirportOfArrival', leg);
                    
                    if ([date, flightNum, origin, destination].some(val => val === 'N/A')) return;

                    const isIncorrect = forbiddenDests.includes(destination.toUpperCase());
                    const row = tableBody.insertRow();
                    populateRow(row, isIncorrect, [date, flightNum, origin, destination]);
                });
            }
            
            function populateRow(row, isIncorrect, data) {
                 row.dataset.status = isIncorrect ? 'incorrect' : 'correct';
                 let rowHTML = '';
                 data.forEach(item => {
                     rowHTML += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700 font-medium">${item}</td>`;
                 });
                 if (isIncorrect) {
                     incorrectCount++;
                     rowHTML += `<td class="px-6 py-4 whitespace-nowrap text-sm text-red-600 font-bold">NO CORRESPONDE ENVIAR</td>`;
                 } else {
                     correctCount++;
                     rowHTML += `<td class="px-6 py-4 whitespace-nowrap text-sm text-green-600 font-bold">OK</td>`;
                 }
                 row.innerHTML = rowHTML;
                 processedCount++;
            }

            if (processedCount > 0) {
                 showStatus(`Procesados ${processedCount} registros. Correctos: ${correctCount}, Incorrectos: ${incorrectCount}. ${errorCount > 0 ? `(${errorCount} con error de formato)` : ''}`, 'success');
            } else if (errorCount > 0) {
                 showStatus(`No se pudo procesar ningún mensaje. Se encontraron ${errorCount} con errores de formato.`, 'error');
            } else {
                showStatus('Procesamiento finalizado. No se encontraron datos relevantes para extraer.', 'info');
            }
            updateTableVisibility();
        }

        function clearAll() {
            xmlInput.value = '';
            tableBody.innerHTML = '';
            showStatus('');
            if (isFilterActive) {
                toggleFilter(); 
            }
            updateTableVisibility();
        }

        function toggleFilter() {
            isFilterActive = !isFilterActive;
            Array.from(tableBody.rows).forEach(row => {
                row.style.display = (isFilterActive && row.dataset.status === 'correct') ? 'none' : '';
            });
            
            if (isFilterActive) {
                filterBtn.textContent = 'Mostrar Todos';
                filterBtn.classList.replace('bg-yellow-600', 'bg-gray-700');
                filterBtn.classList.replace('hover:bg-yellow-700', 'hover:bg-gray-800');
            } else {
                filterBtn.textContent = 'Mostrar solo incorrectos';
                filterBtn.classList.replace('bg-gray-700', 'bg-yellow-600');
                filterBtn.classList.replace('hover:bg-gray-800', 'hover:bg-yellow-700');
            }
        }

        function copyTableToClipboard() {
            if (tableBody.rows.length === 0) return showStatus('No hay datos para copiar.', 'error');
            
            let textToCopy = Array.from(tableHeader.querySelectorAll('th')).map(th => th.textContent).join('\t') + '\n';
            Array.from(tableBody.rows).forEach(row => {
                if (row.style.display !== 'none') {
                    textToCopy += Array.from(row.cells).map(cell => cell.textContent).join('\t') + '\n';
                }
            });
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showStatus('¡Tabla copiada al portapapeles!', 'success');
                copyBtn.textContent = '¡Copiado!';
                setTimeout(() => { copyBtn.textContent = 'Copiar Tabla'; }, 2000);
            }, () => showStatus('Error al copiar la tabla.', 'error'));
        }

        function exportToXLS() {
            if (tableBody.rows.length === 0) return showStatus('No hay datos para exportar.', 'error');

            const type = messageType.value;
            const table = document.getElementById('resultsTable');
            const wb = XLSX.utils.table_to_book(table, {sheet: `Resultados ${type}`});
            const ws = wb.Sheets[`Resultados ${type}`];
            const range = XLSX.utils.decode_range(ws['!ref']);
            const statusColIndex = Array.from(tableHeader.querySelectorAll('th')).findIndex(th => th.textContent === 'Status');

            const headerStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "2d3748" } }, alignment: { horizontal: "center" } };
            ws['!cols'] = Array.from({length: range.e.c + 1}, () => ({wch: 20}));

            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cellRef = XLSX.utils.encode_cell({c: C, r: range.s.r});
                if(ws[cellRef]) ws[cellRef].s = headerStyle;
            }

            for (let R = range.s.r + 1; R <= range.e.r; ++R) {
                if (statusColIndex > -1) {
                    const statusCellRef = XLSX.utils.encode_cell({c: statusColIndex, r: R});
                    if (ws[statusCellRef]) {
                        const statusValue = ws[statusCellRef].v;
                        if (statusValue === 'NO CORRESPONDE ENVIAR') {
                            ws[statusCellRef].s = { font: { bold: true, color: { rgb: "C00000" } }, fill: { fgColor: { rgb: "FFC7CE" } } };
                        } else if (statusValue === 'OK') {
                            ws[statusCellRef].s = { font: { bold: true, color: { rgb: "006100" } }, fill: { fgColor: { rgb: "C6EFCE" } } };
                        }
                    }
                }
            }

            try {
                XLSX.writeFile(wb, `Resultados_${type}.xlsx`);
                showStatus('Exportado a XLS exitosamente!', 'success');
            } catch (err) {
                showStatus('Error al exportar la tabla.', 'error');
            }
        }
        
        // --- Event Listeners ---
        processBtn.addEventListener('click', processXMLs);
        clearBtn.addEventListener('click', clearAll);
        copyBtn.addEventListener('click', copyTableToClipboard);
        exportBtn.addEventListener('click', exportToXLS);
        filterBtn.addEventListener('click', toggleFilter);
        messageType.addEventListener('change', () => {
             updateTableHeaders(messageType.value);
             clearAll();
        });

        // --- Initial Setup Call ---
        updateTableHeaders(messageType.value);
        updateTableVisibility();
    </script>
</body>
</html>

